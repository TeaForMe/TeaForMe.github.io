# 网络相关

```text
TCP握手协议 
在TCP/IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接.
第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认； 
SYN：同步序列编号(Synchronize Sequence Numbers)
第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态； 
第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.
```

完成三次握手,客户端与服务器开始传送数据

A与B建立TCP连接时：首先A向B发SYN（同步请求），然后B回复SYN+ACK（同步请求应答），最后A回复ACK确认，这样TCP的一次连接（三次握手）的过程就建立了！



## 一、TCP报文格式

TCP/IP协议的详细信息参看《TCP/IP协议详解》三卷本。下面是TCP报文格式图：

![img](https://pic2.zhimg.com/80/v2-9d3713a601aaa360762ee6ff256bcc55_720w.jpg)图1 TCP报文格式



上图中有几个字段需要重点介绍下：

（1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。

（2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。

（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：

（A）URG：紧急指针（urgent pointer）有效。

（B）ACK：确认序号有效。

（C）PSH：接收方应该尽快将这个报文交给应用层。

（D）RST：重置连接。

（E）SYN：发起一个新连接。

（F）FIN：释放一个连接。



需要注意的是：

（A）不要将确认序号Ack与标志位中的ACK搞混了。

（B）确认方Ack=发起方Req+1，两端配对。



## 二、三次握手

所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：

![img](https://pic1.zhimg.com/80/v2-dc63a6b78ca7c29e368eee2cde5ce89c_720w.jpg)图2 TCP三次握手



（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

SYN攻击：

在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：

\#netstat -nap | grep SYN_RECV

## 三、四次挥手

三次握手耳熟能详，四次挥手估计就，所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：

![img](https://pic3.zhimg.com/80/v2-024c7f53430096d02c1fbbdc893c3b7a_720w.jpg)图3 TCP四次挥手



由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。

（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：



![img](https://pic4.zhimg.com/80/v2-6a0b2d6630304b6db5da2f1864dacd5b_720w.jpg)图4 同时挥手



流程和状态在上图中已经很明了了，在此不再赘述，可以参考前面的四次挥手解析步骤。



四、附注

关于三次握手与四次挥手通常都会有典型的面试题，在此提出供有需求的XDJM们参考：

### （1）三次握手是什么或者流程？四次握手呢？答案前面分析就是。

### （2）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

五、常见面试题



## TCP协议和UDP协议的区别是什么

TCP协议是有连接的，有连接的意思是开始传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接。而UDP是无连接的

TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。

TCP协议所需资源多，TCP首部需20个字节（不算可选项），UDP首部字段只需8个字节。

TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率

TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信。

TCP面向的是字节流的服务，UDP面向的是报文的服务。

### TCP介绍和UDP介绍

请详细介绍一下TCP协议建立连接和终止连接的过程？

助于理解的一段话

两幅图（来源）：

建立连接：三次握手

![img](https://pic3.zhimg.com/80/v2-6594ca6d9f97903fc1b1a82bf7196672_720w.jpg)

关闭连接：四次挥手

![img](https://pic2.zhimg.com/80/v2-f47826f8f3f1a0baa88f40aed8d0d1ad_720w.jpg)

### 三次握手建立连接时，发送方再次发送确认的必要性？

主 要是为了防止已失效的连接请求报文段突然又传到了B,因而产生错误。假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络结 点长时间滞留了，一直延迟到连接释放以后的某个时间才到达B，本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次 新的连接请求，于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了，这样一直等待A发来数据，B的许多 资源就这样白白浪费了。

### 四次挥手释放连接时，等待2MSL的意义？

第 一，为了保证A发送的最有一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN和ACK 报文段的确认。B会超时重传这个FIN和ACK报文段，而A就能在2MSL时间内收到这个重传的ACK+FIN报文段。接着A重传一次确认。

第二，就是防止上面提到的已失效的连接请求报文段出现在本连接中，A在发送完最有一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。



## 常见的应用中有哪些是应用TCP协议的，哪些又是应用UDP协议的，为什么它们被如此设计？

## 以下应用一般或必须用udp实现？

多播的信息一定要用udp实现，因为tcp只支持一对一通信。

如果一个应用场景中大多是简短的信息，适合用udp实现，因为udp是基于报文段的，它直接对上层应用的数据封装成报文段，然后丢在网络中，如果信息量太大，会在链路层中被分片，影响传输效率。

如果一个应用场景重性能甚于重完整性和安全性，那么适合于udp，比如多媒体应用，缺一两帧不影响用户体验，但是需要流媒体到达的速度快，因此比较适合用udp

如果要求快速响应，那么udp听起来比较合适

如果又要利用udp的快速响应优点，又想可靠传输，那么只能考上层应用自己制定规则了。

常见的使用udp的例子：ICQ,QQ的聊天模块。

以qq为例的一个说明（转载自知乎）

登陆采用TCP协议和HTTP协议，你和好友之间发送消息，主要采用UDP协议，内网传文件采用了P2P技术。总来的说：

1.登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有一个TCP连接来保持在线状态。

2.和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。

3.如果是在内网里面的两个客户端传文件，QQ采用的是P2P技术，不需要服务器中转。



![img](https://pic2.zhimg.com/80/v2-b1e1f801fd8cf16391901450d8b14a11_720w.jpg)

## TCP/IP网络分层

### 网络分层架构

业内普遍的分层方式有两种。OSI七层模型 和TCP/IP四层模型。
OSI七层模型：物、数、网、传、会、表、应
TCP/IP四层模型：链、网、传、应
1) 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。
2)数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1
3)网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。
4) 传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。
5) 会话层：通过传输层(端口号：传输端口接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。
6)表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。
7) 应用层：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。

分层功能示意：
OSI七层模型结构体： 物、数、网、传、会、表、应
TCP/IP 四层模型：数、网、传、应


链路层：
1
以太网规定，连入网络的所有设备，都必须具有“网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。通过网卡能够使不同的计算机之间连接，从而完成数据通信等功能。网卡的地址——MAC 地址（全球唯一），就是数据包的物理发送地址和物理接收地址。

链路层速记：ARP（核心协议）
源mac —— 目标mac
ARP 协议作用： 借助 IP 获取 mac 地址。

*: MAC 地址是绑定在网卡上的
IP：地址则是管理员分配的

网络层：
1
网络层的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做“网络地址”，这是我们平时所说的IP地址。网络层协议包含的主要信息是源IP和目的IP。

网络层速记：IP（核心协议）
源IP —— 目标IP
IP协议的作用： 在 网络环境中唯一标识一台主机。
IP地址本质：2进制数。—— 点分十进制 IP地址 （string）
IP和MAC的作用：
网络地址（IP）:帮助我们确定计算机所在的子网络
MAC 地址:则将数据包送到该子网络中的目标网卡。
处理顺序：从逻辑上可以推断，必定是先处理网络地址，然后再处理 MAC 地址

传输层：
1
端口:确定进程
1， 对于同一个端口，在不同系统中对应着不同的进程
2，对于同一个系统，一个端口只能被一个进程拥有

传输层速记：TCP / UDP（核心协议）
port —— 在 一台主机上唯一标识一个进程。

应用关系：
1
通过网络层IP确认交互端，通过MAC确认信息发送目标，最终通过端口指定要发生信息交互的程序



应用层
1
接到传输层传递过来的数据就要对数据进行解析，应用层就是规定程序的数据格式
应用层速记：ftp、http、自定义
对数据进行封装。 解封装

TCP/IP:TCP/IP协议是一个大家族，不仅仅只有TCP和IP协议，它还包括其它的协议

网络通信过程
数据通信：
封装： 应用层 —— 传输层 —— 网络层 —— 链路层 。 没有经过封装的数据，不能在网
络环境中传递。
解封装 ： 链路层 —— 网络层 —— 传输层 —— 应用层


socket:
套接字。
网络通信过程中，socket 一定是成对出现的。
1,在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。
2,IP地址+端口号:就对应一个socket。
3,欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识
一个连接。
4,Socket来描述网络连接的一对一关系。
5,常用的Socket类型有两种：流式Socket（SOCK_STREAM）和数据报式Socket（SOCK_DGRAM）。
a)流式是一种面向连接的Socket，针对于面向连接的TCP服务应用；
b)据报式Socket是一种无连接的Socket，对应于无连接的UDP服务应用。
关于通信：

mac地址（不需要用户指定） (ARP 协议)Ip ——> mac
IP 地址 （需要用户指定） —— 确定主机
port 端口号 （需要用户指定） —— 确定程序
不能使用系统占用的默认端口。 5000+ 端口我们使用 （8080）
65535为端口上限。
C/S架构设计的优缺点：
优点：1，性能：客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而提高数据传
输效率。
2，协议灵活：户端和服务器程序由一个开发团队创作
缺点：1,成本高 客户端服务端都需要独立开发
2,独立安装客户端对用户来说有安全隐患

TCP:CS开发架构（代码层面）




TCP通信过程：

三次握手：
	1. 主动发起请求端， 发送 SYN 
	2. 被动建立连接请求端 ， 应答ACK 同时 发送 SYN
	3. 主动发起请求端，发送应答 ACK
	* 标志 TCP 三次握手建立完成。 —— server：Accept() 返回 。— client：Dial() 返回。

四次挥手：
	1. 主动关闭连接请求端， 发送 FIN
	2. 被动关闭连接请求端 ，应答 ACK
					标志。半关闭完成。 —— close()
	3. 被动关闭连接请求端 ，发送 FIN
	4.  主动关闭连接请求端，应答 ACK
					标志。四次挥手建立完成。 —— close().

### 二三层转发原理

#### 二层转发原理（交换机转发原理）

二层转发原理也就是交换机的转发原理
交换机转发原理：学习源MAC，根据目的MAC转发
看这篇文章的人，应该至少都接触过gns3,ensp,PT,eve等软件或者直接接触过真机。
下面就开始正式讲解一下二层转发原理：在OSI和TCP/IP模型中，交换机都在二层，转发数据帧。
下图是数据帧的格式
在最开始就说了二层转发原理就是学习源MAC地址，根据目的MAC地址转发。
当一个数据帧到达交换机后，交换机学习源MAC地址，将该MAC地址添加到自己的MAC地址表中；然后查看自己的MAC地址表，根据目的MAC地址转发。
数据帧分为4种，单播帧、广播帧、组播帧、未知单播帧（这个我就不详解了，大家可以自行去了解一下）
假设一台交换机上不配置任何东西，直连两台PC机，且PC机处于同一网段。PC机会先发送ARP请求，请求对端的MAC地址，交换机在ARP报文的交互过程中，学习源MAC地址，根据目的MAC地址转发。
从下面的一个抓包中可以看出PC1先发出的ARP请求的目的MAC是广播，ARP响应是单播。
交换机接收到ARP请求报文，学习源MAC地址，然后将该MAC地址对应到接收到该数据帧的端口（假如从1端口收到一个ARP请求报文，MAC地址表中 1 端口对应的MAC地址就是收到的报文中的源MAC地址）接收到回包后学习对端的MAC地址，然后构建了一个完整的MAC地址表，双发就能互通。
因为是同一网段，且只用交换机，数据接封装只会解到二层。
因为有了ARP请求，PC1中的ARP表有了PC2的地址，封装数据帧后，交换机接收到该数据帧，根据目的MAC地址转发，PC2收到该数据包，因为目的MAC是自己，解二层，因为目的IP是自己，解封装，看到数据是icmp，然后回包。

#### 三层转发原理（路由器转发原理）
三层转发原理就是路由器的转发原理
路由器的转发原理就是根据路由表转发，路由表中有路由才会转发，无路由则直接丢弃
PC1 ping PC2，PC1 看路由、网关，主机先找到自己的网关，先发送ARP请求，在ARP表中找到对应关系，把数据包转发给网关，网关所在路由器解封装，根据路由表确定出接口，下一跳，然后重新封装，源MAC是出接口，目的MAC是下一跳，但是MAC地址表中无下一跳MAC地址，所以先发送ARP请求，更新MAC地址后在转发包，直到数据包中解封装后目的IP地址直连后，重新解封装，查看MAC地址表，然后ARP请求目的IP地址的MAC地址，然后发给目标主机。目标主机接收后，拆解数据包，然后原路放回数据包，完成传输。
下面是R1-R2,R2-R3之间的抓包
在这个环境中IP头部数据始终不变，MAC头部在经过一个路由器时就会发生改变。因为在路由器是三层设备，传输数据时会解封装到IP头部。

## Fiddler抓包原理

### Fiddler工作原理

Fiddler是位于客户端和服务器端之间的HTTP代理， 它能够记录客户端和服务器之间的所有 HTTP(S)请求，可以针对特定的HTTP(S)请求，分析网络传输的数据，还可以设置断点、修改请求的数据和服务器返回的数据。
Fiddler在浏览器与服务器之间建立一个代理服务器，Fiddler工作于七层中的应用层，能够捕获通过的HTTP(S)请求。Fiddler启动后会自动将代理服务器设置成本机，默认端口为8888。Fiddler不仅能记录PC上浏览器的网络请求数据，还可以记录同一网络中的其他设备的HTTP(S)请求数据。数据传递流程大致如下：
![img](https://www.luoxudong.com/wp-content/uploads/2018/03/20180303002257_15427.png)
1) 客户端像WEB服务器发送HTTP(S)请求时，请求会先经过代理Fiddler代理服务器。
2) Fiddler代理服务器截取客户端的请求报文，再转发到WEB服务器，转发之前可以做一些请求报文参数修改的操作。
3) WEB服务器处理完请求以后返回响应报文，Fiddler代理服务器会截取WEB服务器的响应报文。
4) Fiddler处理完响应报文后再返回给客户端。

### Fiddler抓取HTTPS原理

现在APP中的数据传输基本上都使用HTTS传输，传输的数据都是经过加密的，这增加了我们分析数据包的难度，还好Fiddler除了可以抓取HTTP数据包，还可以抓取HTTPS数据包。由于HTTPS传输需要使用到CA证书，所以抓取抓取HTTPS数据包时需要做一些特殊配置。Fiddler截取HTTPS报文的流程大致如下：
![img](https://www.luoxudong.com/wp-content/uploads/2018/03/20180303002319_70386.png)
1) 客户端请求建立HTTPS链接，发送客户端支持的加密协议及版本列表等信息给服务器端。
2) Fiddler接受客户端请求并伪装成客户端向WEB服务器发送相同的请求。
3) WEB服务器收到Fiddler的请求以后，从请求中筛选合适的加密协议。并返回服务器CA证书，证书中包括公钥信息。
4) Fiddler收到WEB服务器的响应后保存服务器证书并自签名一个CA证书，伪装成服务器，把该证书下发给客户端。
5) 客户端验证证书合法性。（Fiddler能否抓取到HTTPS报文关键看这一步）
6) 客户端生产对称密钥，通过证书的公钥加密发送给服务器。
7) Fiddler拦截客户端的请求以后，使用私钥解密该报文，获取对称加密秘钥，并使用服务器证书中带的公钥加密该对称密钥发送给WEB服务器。此时对称密钥已经泄露了，以后可以使用该秘钥界面客户端和服务器端传输的数据。
8) WEB服务器接收到客户端发送的加密的对称密钥后使用私钥解密，并使用对称密钥加密测试数据传给客户端。
9) Fiddler使用前面获取的对称密钥解密报文。
10) 客户端验证数据无误以后HTTPS连接就建立完成，客户端开始向服务器发送使用对称密钥加密的业务数据
11) Fiddler使用前面获取的对称密钥解密客户端发送的数据并重新加密转发给客户端。